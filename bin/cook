#!perl
use v5.10;
use strict;
use warnings;

use experimental qw(signatures);

use File::Basename;
use File::FindLib 'lib';
use File::Path qw(make_path);
use Local::Template::Utils;
use Mojo::Template::Sandbox;

use Carp qw(carp croak);
use File::Spec::Functions;
use Hash::AsObject;
use Mojo::JSON qw(encode_json);
use Mojo::Log;
use Mojo::Template;
use Mojo::Util qw(dumper);

my $log    = get_logger();
my $config = get_config();

my @items;

my @posts = glob( "_posts/*.html" );
foreach my $file ( @posts ) {
	my( $header, $content ) = split_doc( $file );
	my $local_path = catfile(
		$config->{base_dir}, local_path( $file, $header ), 'index.html'
		);
	process_file( $file, $local_path );
	}

add_cname();
make_json( \@items );

make_category_pages( \@items );
make_tags_pages( \@items );

my @pages = glob( "_templates/*.html" );
foreach my $file ( @pages ) {
	my $local_path = catfile( $config->{base_dir}, $file =~ s|_templates/||r );
	process_file( $file, $local_path, $file );
	}

sub add_cname () {
	open my $fh, '>:encoding(UTF-8)', catfile( $config->{base_dir}, 'CNAME' );
	say { $fh } $config->{cname};
	}

sub process_file ( $file, $local_path, $template_path = undef ) {
	$log->debug( "File: <$file>" );
	$log->debug( "Local: <$local_path>" );
	$log->debug( sprintf "Template: <%s>", $template_path // '' );
	Mojo::Template::Sandbox::clear_vars();
	my( $header, $content ) = split_doc( $file );

	my $vars = {
		file               => $file,
		processing_epoch   => time,
		processing_datestr => scalar CORE::localtime,
		post_epoch         => get_epoch_time( $header->{date} ),
		local_path         => $local_path,
		content            => $content,
		web_path           => Mojo::URL->new( $header->{link} )->path,
		config             => $config,
		$header->%*,
		};
	Mojo::Template::Sandbox::set_vars( $vars );

	$template_path //= (
		grep { -e }
		map  { catfile( $config->{template_dir}, $_ ) }
		( $header->{type}, $config->{template} )
		)[0];

	$log->debug( "Template path is <$template_path>" );

	unless( defined $template_path ) {
		$log->error( "No template for <$file>" );
		return;
		}

	my $cooked = get_templater()->render_file( $template_path );

	write_page( $local_path, $cooked );

	push @items, do { my %h = $vars->%*; delete $h{content}; \%h };
	}

sub write_page ( $local_path, $content ) {
	make_path( dirname($local_path) );

	open my $fh, '>:encoding(UTF-8)', $local_path;
	say $fh $content;
	close $fh;
	}

sub make_category_pages ( $items ) {
	make_labelled_pages( $items, 'categories', $config->{category_dir} );
	}

sub make_json ( $items ) {
	open my $fh, '>:raw', $config->{items_json} or do {
		$log->error( "Could not open <$config->{items_json}> for writing: $!" );
		exit 1;
		};
	print { $fh } encode_json( $items );
	close $fh;
	}

sub make_tags_pages ( $items ) {
	make_labelled_pages( $items, 'tags', $config->{tag_dir} );
	}

sub make_labelled_pages ( $items, $key, $subdir ) {
	my $inverted = invert_items( $items, $key );

	my $title_label = $key;
	$title_label =~ s/ies\z/y/;
	$title_label =~ s/s\z//;
	$title_label = ucfirst( $title_label );

	foreach my $label ( keys $inverted->%* ) {
		$log->debug( "label is <$label>" );
		make_path catfile( $config->{base_dir}, $subdir, $label );

		Mojo::Template::Sandbox::clear_vars();
		my $vars = {
			processing_epoch   => time,
			processing_datestr => scalar CORE::localtime,
			items => $inverted->{$label},
			config => $config,
			title  => "$title_label: $label",
			};
		Mojo::Template::Sandbox::set_vars( $vars );

		my $template_path = catfile( $config->{template_dir}, $key );
		$log->debug( "Template path is <$template_path>" );

		unless( defined $template_path ) {
			$log->error( "No template for <$key>" );
			return;
			}

		my $local_path = catfile( $config->{base_dir}, $subdir, $label, 'index.html' );
		my $cooked = get_templater()->render_file( $template_path );
		write_page( $local_path, $cooked );
		}

	}


sub invert_items ( $items, $key ) {
	my $hash;

	foreach my $item ( sort { $b->{post_epoch} <=> $a->{post_epoch} } @items ) {
		next unless length $item->{$key};
		$log->debug( "$key is <$item->{$key}>" );
		foreach my $thing ( split /\s+/, $item->{$key} ) {
			$log->debug( "thing is <$thing>" );
			push $hash->{ $thing }->@*, $item;
			}
		}

	$hash;
	}
